# 比较泛的面试问题（非前端）

## 编程语言

### Java 的三大特性

- **封装**：将数据和操作封装在类中，通过访问修饰符控制对类成员的访问，提高代码的安全性和可维护性。
- **继承**：子类继承父类的属性和方法，实现代码的复用，同时可以在子类中进行扩展和重写。
- **多态**：同一操作作用于不同的对象可以有不同的表现形式，通过方法重写和方法重载实现。

### 多态实现原理

多态主要通过方法重写和方法重载实现。在继承关系中，子类重写父类的方法，通过父类引用调用重写后的方法时，实际执行的是子类的方法，这就是多态的一种表现形式。方法重载是在同一个类中，定义多个同名但参数不同的方法，根据传入的参数不同来确定调用哪个方法。

## 数据结构与算法

### 链表

#### 反转链表（迭代法）

```c
struct ListNode { // 单链表结点定义
    int val;      // 结点值
    ListNode* next; // 指向下一个结点的指针
};

ListNode* reverseList(ListNode* head) { // 迭代反转单链表，返回新头结点
    ListNode* prev = nullptr; // 已反转部分的前驱指针，初始为空
    ListNode* curr = head;    // 当前遍历的结点
    while (curr != nullptr) { // 遍历直到链表尾部
        ListNode* next = curr->next; // 暂存后继，防止断链
        curr->next = prev;           // 反转当前结点指针指向
        prev = curr;                 // 前驱前移到当前结点
        curr = next;                 // 当前指针前进到原后继
    }
    return prev; // 返回新的头结点（原链表的尾结点）
}
```

#### 链表使用场景优缺点

**使用场景：**

**动态数据结构：** 链表的长度可以动态变化，适合存储数量不确定的数据。
**频繁插入和删除：** 在链表中进行插入和删除操作只需要修改指针，时间复杂度为 O (1)，比数组高效。

**优点：**

**动态大小：** 可以根据需要随时增加或减少节点数量。
**高效的插入和删除：** 不需要移动大量数据，只需修改指针。

**缺点：**

**随机访问困难：** 不像数组可以通过索引直接访问元素，链表需要从头节点开始遍历才能找到特定的节点。
**占用额外的内存空间：** 每个节点都需要存储指向下一个节点的指针，增加了内存开销。
### 二叉树

#### 二叉树的重要性质（结点数量）

1. 第 i 层上至多有 _2^(i - 1)_ 个结点
2. 深度为 k 的二叉树 **至多** 有 _2^k - 1_ 个结点 
3. 对任意一颗二叉树，_n0 = n2 + 1_

证明（可推理任何 T 元树（有根有向树））如下：

设有一棵有限的有根有向 T-元树（每个结点的出度 $\le T$ ）。记

•	$n$ 为结点总数，
•	$n_k$ 为出度为 k 的结点个数（$k=0,1,\dots,T$），
•	$B$ 为边（弧）的总数。

显然
$$n = n_0 + n_1 + n_2 + \cdots + n_T. \tag{1}$$

由于树是有根的、每个非根结点恰有一条入边，所以边的总数等于结点数减一：
$$B = n - 1. \tag{2}$$

另一方面，按出度分类，每个出度为 k 的结点贡献 k 条出边，因此
$$B = 1\cdot n_1 + 2\cdot n_2 + \cdots + T\cdot n_T. \tag{3}$$

由(2)与(3)得到
$$n - 1 = n_1 + 2n_2 + \cdots + T n_T,$$
即
$$n = n_1 + 2n_2 + \cdots + T n_T + 1. \tag{4}$$

将(1)与(4)相减（左边 $n$ 相同，右边相减得到 $n_0$）：
$$n_0 = (n_1 + n_2 + \cdots + n_T) - (n_1 + 2n_2 + \cdots + T n_T) + 1.$$
化简项得到
$$ n_0 = n_2 + 2n_3 + 3n_4 + \cdots + (T-1)n_T + 1.$$

这是对一般 T-元树的关系。
当 $T=2$（二叉树）时，所有 $n_3,n_4,\dots,n_T$ 都为 0，所以上式化为
$$n_0 = n_2 + 1$$
#### 根据中序遍历 (LDR) + 先序/后序遍历 确定唯一的二叉树

**先序或后序遍历可以确定根结点；通过中序遍历可以划分左右子树。**
递归上述过程，可以确定唯一的二叉树。

### 查找

### 排序

#### 插入排序

##### 直接插入排序

将序列划分为已排序区和未排序区。每次从未排序区取出一个元素，插入到已排序区的合适位置，使已排序区保持有序。插入过程通过向左扫描并右移所有比它大的元素来完成，适合小规模或近乎有序的数据，稳定。

1. 从索引 1 开始，视 `array[0...i-1]` 为已排序。
2. 取当前元素 `array[i]` 为 `temp`，若 `temp` 小于前驱则进入插入流程。
3. 从 `j=i-1` 向左扫描，凡比 `temp` 大的元素右移一位。
4. 扫描结束后，将 `temp` 放到 `j+1` 位置。
5. 重复直到末尾。

```js
let InsertSort = (array) => { // 定义插入排序函数，参数为数组
    let i, j // 外层和内层循环索引
    let temp // 临时存储当前待插入的元素
    for( i = 1; i < array.length; i++) { // 从索引 1 开始遍历，左侧视为已排序
        if (array[i] < array[i-1]) { // 当前元素比前一元素小，启动插入流程
            temp = array[i] // 把当前元素保存到临时变量
            array[i] = array[i - 1] // 先将前一个元素右移一位，为插入腾出空间
            for ( j = i-1; j >= 0 && array[j] > temp; j--) { // 向左扫描，移动所有大于 temp 的元素
                array[j + 1] = array[j] // 将较大的元素右移一位
            } // 内层循环结束
            array[j + 1] = temp // 在正确位置插入 temp
        } // 条件判断结束
    } // 外层循环结束
} // 函数结束
```

##### 希尔排序

先将整个待排序记录序列分割为几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样，当经过几次分组排序后，整个序列中的元素基本有序，再进行一次直接插入排序，即可完成排序。

希尔排序的分组，不是简单地将序列分成等长的子序列，而是根据一个增量序列进行分组。增量序列的最后一个增量必须为 1，即最后一次排序时，整个序列被分为一组，进行直接插入排序。

1. 第一趟取增量 $d_1 (d_1 < n)$，把全部记录分成 $d_1$ 组，所有间隔为 $d_1$ 的记录分在同一组，对每组分别进行直接插入排序。
2. 第二趟取增量 $d_2 (d_2 < d_1)$，把全部记录分成 $d_2$ 组，所有间隔为 $d_2$ 的记录分在同一组，对每组分别进行直接插入排序。
3. 重复以上过程，直到取增量为 1，即最后一次排序时，整个序列被分为一组，进行直接插入排序。

#### 交换排序

##### 冒泡排序

通过相邻元素的比较与交换，使较大的元素逐步“冒泡”到序列右端。每一趟都能确定一个最大值的位置；若某一趟未发生交换，则序列已整体有序，可提前结束。算法简单、稳定，适合教学与入门。

1. 外层控制趟数，共 `n-1` 趟。
2. 内层从头到 `n-i-2` 比较相邻元素，若逆序则交换。
3. 若某一趟没有发生交换，说明序列已有序，提前退出。

```js
function BubbleSort(arr) { // 冒泡排序（含提前退出优化），返回有序新数组
    let flag = 1            // 标志位：上一轮是否发生交换；用于提前结束
    let array = [...arr]    // 复制原数组，避免修改入参

    for (let i = 0; i < array.length - 1 && flag; i++) { // 外层循环控制趟数；若上一趟无交换则提前退出
        flag = 0           // 新一趟开始前重置标志位
        for (let j = 0; j < array.length - i - 1; j++) { // 内层循环：比较相邻元素，将较大值向右“冒泡”
            if (array[j] > array[j+1]) { // 若前一个元素比后一个大则交换
                let temp = array[j]      // 交换相邻元素
                array[j] = array[j+1]
                array[j+1] = temp
                flag = 1                 // 本趟发生交换，保持继续下一趟
            }
        } 
    }

    return array            // 返回排序后的数组副本
}
```

##### 快速排序(双指针法)

分治思想：选取枢轴，将序列按与枢轴的大小关系划分为两个子序列（左侧小于等于枢轴，右侧大于等于枢轴），再递归地对两侧排序。本实现采用双指针“填坑”法进行原地分区，空间开销低。

1. 选枢轴：取子数组首元素 `arr[low]`。
2. 分区：设 `low`、`high` 双指针向中间收缩。右侧向左找第一个小于枢轴的元素填到左坑；左侧向右找第一个大于枢轴的元素填到右坑。
3. 当 `low==high` 时，将枢轴放回该位置，分区完成，返回枢轴下标。
4. 分别递归处理左区间 `[low, pivotLoc-1]` 与右区间 `[pivotLoc+1, high]`。

```js
function QuickSort(arr) { // 快速排序入口函数，返回有序新数组
    let array = [...arr]   // 复制入参，避免修改原数组
    QSort(array, 0, array.length - 1) // 对整个区间进行原地快排
    return array           // 返回排序结果副本
}

function QSort(arr, low, high) { // 对区间 [low, high] 原地快速排序
    if (low < high) { // 递归终止：当区间长度 ≤ 1 时无需处理
        let pivotLoc = Partition(arr, low, high) // 分区，得到枢轴的最终位置
        QSort(arr, low, pivotLoc - 1)            // 递归排序枢轴左半段
        // QSort(arr, pivotLoc, high)
        // 错因：右半段递归用了 pivotLoc 而不是 pivotLoc + 1 。当 pivotLoc === low 时，区间不缩小，递归死循环。
        QSort(arr, pivotLoc + 1, high)           // 递归排序枢轴右半段（从 pivotLoc+1 开始）
    }
}

function Partition(arr, low, high) { // 双指针分区（“填坑”法），返回枢轴最终位置
    // const pivotKey = arr[0] 
    // 错因：分区函数总是用 arr[0] 作为枢轴，而不是当前子数组的 arr[low] ，递归到子数组时分区错误，也会让递归无法收敛。
    const pivotKey = arr[low] // 选当前子数组首元素为枢轴值

    while (low < high) { // 双指针向中间收缩
        while (low < high && arr[high] >= pivotKey) high-- // 右侧寻找第一个 < pivot 的元素
        arr[low] = arr[high]                                // 填左侧“坑”：把较小值放到左侧
        while (low < high && arr[low] <= pivotKey) low++   // 左侧寻找第一个 > pivot 的元素
        arr[high] = arr[low]                                // 填右侧“坑”：把较大值放到右侧
    }
    arr[low] = pivotKey   // 将枢轴放回最终位置（low）
    return low            // 返回枢轴位置供上层递归使用
}
```

#### 选择排序

##### 简单选择排序

每一趟在未排序区间中选择最小元素，将其与当前起始位置交换，扩大已排序区。选择排序比较次数固定、交换次数较少，但总体效率仍为 `O(n^2)`，且通常不稳定。

1. 外层遍历 `i=0...n-1`，视 `array[0...i-1]` 为已排序。
2. 在未排序区 `[i, n-1]` 中扫描，记录最小值的下标 `minIndex`。
3. 若 `minIndex != i`，交换 `array[minIndex]` 与 `array[i]`。

```js
let SelectSort = (arr) => {
    let n = arr.length
    let array = [...arr]
    // 外层循环：遍历整个数组，i 表示当前已排序部分的末尾索引
    for (let i = 0; i < n; i++) {
        let minIndex = i
        // 内层循环：在未排序区域 [i+1, n-1] 中查找实际的最小元素
        for (let j = i + 1; j < n; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j
            }
        }
        // 如果找到的最小元素不是当前位置 i 的元素，则进行交换
        if (minIndex !== i) {
                [array[minIndex], array[i]] = [array[i], array[minIndex]]
            }
    }
    return array
}
```

#### 归并排序

分治与合并：递归地将序列二分，分别排序后再线性合并两个有序子序列，得到更大的有序序列。归并排序稳定，时间复杂度为 `O(n log n)`。

1. 将区间 `[low, high]` 二分为 `[low, mid]` 与 `[mid+1, high]`。
2. 递归地对两段排序。
3. 使用两个指针分别指向两段起始位置，比较当前元素并将较小者写入辅助数组。
4. 将剩余元素依次写入辅助数组。
5. 将辅助数组的 `[low...high]` 拷贝回原数组。

```js
// 相邻两个有序子序列的合并
// 将 src[low...mid] 和 src[mid+1...high] 合并到 res
function Merge(src, res, low, mid, high) {
    let i = low, j = mid + 1, k = low
    while (i <= mid && j <= high) {
        if (src[i] <= src[j]) res[k++] = src[i++]
        else res[k++] = src[j++]
    }
    while (i <= mid) res[k++] = src[i++]
    while (j <= high) res[k++] = src[j++]
}

// 归并排序
// 将 src 归并排序后放入 res 中
function MSort(src, res, low, high) {
    if (low >= high) return
    const mid = (low + high) >> 1
    MSort(src, res, low, mid)
    MSort(src, res, mid + 1, high)
    Merge(src, res, low, mid, high)
    for (let i = low; i <= high; i++) src[i] = res[i]
}

function MergingSort(arr) {
    const tmp = new Array(arr.length)
    MSort(arr, tmp, 0, arr.length - 1)
    return arr
}
```

## 计算机网络

### 七层结构与协议

### 常见端口

|**端口号**|**协议/服务**|**备注**|
|---|---|---|
|20/21|FTP|21 控制，20 数据（古典传输方式）|
|22|SSH|远程登录的常客|
|23|Telnet|明文传输的上古神器，基本淘汰|
|25|SMTP|发邮件|
|53|DNS|TCP/UDP 都有，域名解析的基石|
|67/68|DHCP|自动分配 IP|
|80|HTTP|明文网页|
|110|POP3|收邮件（较旧）|
|123|NTP|网络时间同步|
|143|IMAP|收邮件（主流）|
|161/162|SNMP|网络设备管理|
|389|LDAP|目录服务|
|443|HTTPS|加密网页，现代互联网的主干|
|465/587|SMTPS / SMTP Submission|加密或客户端发送邮件|
|993|IMAPS|加密的 IMAP|
|3306|MySQL|数据库|
|5432|PostgreSQL|数据库|
|6379|Redis|缓存/键值存储|
|27017|MongoDB|文档数据库|

### 常见响应状态码

|**状态码**|**意义**|**描述**|
|---|---|---|
|200|OK|一切顺利|
|201|Created|资源成功创建|
|204|No Content|成功但无内容返回|
|301|Moved Permanently|永久重定向|
|302|Found|临时重定向|
|304|Not Modified|客户端可用缓存|
|400|Bad Request|请求格式不对|
|401|Unauthorized|缺少认证|
|403|Forbidden|有身份但没权限|
|404|Not Found|找不到资源|
|405|Method Not Allowed|方法不被允许|
|408|Request Timeout|请求超时|
|429|Too Many Requests|触发限流|
|500|Internal Server Error|服务器内部错误|
|502|Bad Gateway|网关收到坏响应|
|503|Service Unavailable|服务不可用（可能在维护）|
|504|Gateway Timeout|上游超时|

### TCP & UDP

连接性：TCP 是面向连接的协议，在通信之前需要建立连接；UDP 是无连接的协议，不需要建立连接。
可靠性：TCP 提供可靠的数据传输，通过确认机制、重传机制和流量控制保证数据的正确传输；UDP 不保证数据的可靠传输，可能会出现丢包、乱序等情况。
传输效率：UDP 传输效率高，因为它不需要建立连接和进行复杂的确认机制；TCP 传输效率相对较低，但保证了数据的可靠性。
头部开销：TCP 头部开销大，因为它需要包含更多的控制信息；UDP 头部开销小。

### 跨域问题
## 操作系统

### 文件系统的作用

### 进程线程协程

**进程**：是操作系统进行资源分配和调度的基本单位，拥有独立的内存空间和系统资源。
**线程**：是进程中的一个执行单元，共享进程的内存空间和系统资源。线程的创建和切换比进程轻量级。
**协程**：是一种用户态的轻量级线程，由程序员自己控制协程的切换，不需要操作系统进行调度。协程的切换开销非常小，可以在一个线程中同时运行多个协程。

### 线程安全

线程安全是指多个线程同时访问一个对象或方法时，不会出现数据不一致或错误的情况。实现线程安全的方法有：

1. 使用同步机制，如锁（互斥锁、读写锁等）、信号量等。
2. 使用不可变对象。
## 计算机组成
