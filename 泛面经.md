# 比较泛的面试问题（非前端）

## 编程语言

### Java OOP

#### 类的基本构成

```java
public class MyClass {
    // 成员变量（属性 / 数据域）
    private int myInt;
    private String myString;

    // 构造方法
    public MyClass() {
        // 无参数构造方法
    }

    public MyClass(int myInt, String myString) {
	    // this 关键字：用于引用当前对象的实例变量。
        this.myInt = myInt;
        this.myString = myString;
    }

    // 成员方法（行为）
    public void printInfo() {
        System.out.println("myInt: " + myInt);
        System.out.println("myString: " + myString);
    }
}
```

#### 实例化对象

要创建一个类的实例（对象），需要使用 `new` 关键字调用类的构造方法。

```java
// 实例化 MyClass 类
MyClass myObject = new MyClass();

// 调用构造方法初始化对象
MyClass myObject2 = new MyClass(10, "Hello");
```

解析：

```java
MyClass myObject; // 声明对象引用变量

myObject = new MyClass(); // 创建一个对象，并且将对象的引用赋值给引用变量 myObject。
```

_p.s. 变量 myObject 中存放的是对 MyClass 对象的一个引用。_


#### 访问对象的数据和方法

在创建一个对象后，其数据和方法可以使用 **点操作符** 来访问和调用。

```java
// 访问对象的数据
int value = myObject2.myInt; // 调用对象 myObject2 的成员变量 myInt

// 调用对象的方法
myObject2.printInfo(); // 调用对象 myObject2 的成员方法 printInfo()
```

#### 基本类型变量和引用类型变量

- **基本类型变量**：也称为 **值类型变量**，它们直接存储在栈内存中，包含了变量的值。基本类型包括 `int`、`float`、`double`、`boolean`、`char` 等。

- **引用类型变量**：也称为 **对象引用变量**，它们存储在栈内存中，但是指向堆内存中的对象。 _（换句话说，引用类型变量存储的是对象的地址，而不是对象本身。）_ 引用类型包括类、接口、数组等。

将一个变量赋值给另一个变量时：

- 如果是基本类型变量，赋值的是变量的值。

- 如果是引用类型变量，赋值的是对象的引用（地址）。**即：将 b 的引用赋值给 a，现在，a 和 b 都指向了同一个对象。**

注意：

- 当执行完 a = b 后，a 和 b 都指向了同一个对象。原先 a 指向的对象被称为“垃圾对象”，因为它没有任何引用指向它，会被 Java 垃圾回收器回收。

- 如果认为不再需要某个对象时，可以显式地将该对象的引用赋值为 `null`，这会告诉 Java 垃圾回收器，该对象不再被引用，可以被回收。

#### NullPointerException

**NullPointerException** 是 Java 中常见的运行时异常，它表示尝试使用一个值为 `null` 的对象引用。

当程序尝试调用一个 `null` 对象的方法或访问其属性时，就会抛出 `NullPointerException` 异常。

```java
MyClass myObject = null;
myObject.printInfo(); // 抛出 NullPointerException 异常
```

为了避免 `NullPointerException` 异常，在使用对象引用之前，应该先检查它是否为 `null`。

```java
if (myObject != null) {
    myObject.printInfo();
}
```

#### 可见性修饰符

Java 中的可见性修饰符包括 `public`、`protected`、`default`（也称为包级可见性）和 `private`。

- **public**：对所有类可见，没有访问限制。
- **protected**：对同一包内的类和所有子类可见。
- **default**：对同一包内的类可见，不包括子类。
- **private**：仅对当前类可见，不包括子类。

_修饰符 private 只能应用在类的成员上，修饰符 public 可以应用在类的成员上，也可以应用在类本身上。_

#### getter 和 setter 方法

在 Java 中，为了封装类的成员变量，通常会使用 getter 和 setter 方法来访问和修改这些变量。getter 方法用于获取变量的值，setter 方法用于设置变量的值。

```java
public class MyClass {
    private int myInt;

    // getter 方法
    public int getMyInt() {
        return myInt;
    }

    // setter 方法
    public void setMyInt(int myInt) {
        this.myInt = myInt;
    }
}
```

#### 静态常量、变量与静态方法

- **常量**是指在类中使用 `final` 关键字修饰的变量，它的值在初始化后不能被修改。

- **静态变量**是指在类中使用 `static` 关键字修饰的变量，它属于类而不是类的实例。**静态变量在类加载时初始化，并且在所有实例之间共享**。

- **静态方法**是指在类中使用 `static` 关键字修饰的方法，它属于类而不是类的实例。**静态方法可以直接通过类名调用，而不需要创建类的实例**。

```java
public class MyClass {
    // 静态变量
    public static int staticInt = 10;

    // 常量
    public final int myFinalInt = 10;

    // 静态方法
    public static void staticMethod() {
        System.out.println("这是一个静态方法");
    }
}
```

调用静态变量和静态方法：

```java
// 调用静态变量
int value = MyClass.staticInt;

// 调用静态方法
MyClass.staticMethod();
```

_实例方法和实例数据都是属于实例的，所以它们在实例创建之后才可以使用。它们是通过引用变量来访问的。静态方法和静态数据可以通过引用变量或者它们的类名来调用。_

#### 将基本数据类型值转换为包装类对象

基本数据类型值不是一个对象，但是可以使用 Java API 中的包装类将其转换为对象。

Java 为基本数据类型提供了 Boolean、Byte、Short、Integer、Long、Float、Double 等包装类。这些包装类都位于 `java.lang` 包中。

```java
import java.lang.*;

int intValue = 10;
Integer integerObject = Integer.valueOf(intValue); // 将 int 转换为 Integer 对象
```

#### 基本类型和包装类型之间的自动转换

在 Java 中，基本数据类型和包装类之间可以进行自动转换。这意味着可以将基本数据类型的值直接赋值给包装类的变量（装箱，boxing），或者将包装类的对象赋值给基本数据类型的变量（拆箱，unboxing）。

```java
Integer intObject = new Integer(2);
// 等价于
Integer intObject2 = 2; // 自动装箱，将 int 转换为 Integer 对象
```

_自动装箱和自动拆箱是 Java 中方便的特性，但是在使用时需要注意空指针异常等问题。_

### Java 三大特性

- **封装**：将数据和操作封装在类中，通过**访问修饰符**控制对类成员的访问，提高代码的安全性和可维护性。
- **继承**：从已经存在的类中定义新的类，称为**继承**。子类继承父类的属性和方法，实现代码的复用，同时可以在子类中进行扩展和重写。
- **多态**：同一操作作用于不同的对象可以有不同的表现形式，通过**方法重写**和**方法重载**实现。

#### 继承

子类可以继承父类的属性和方法，同时可以在子类中进行扩展和重写。子类可以使用 `super` 关键字调用父类的方法，也可以使用 `this` 关键字调用当前类的方法。

##### 使用 extends 关键字

```java
class Parent {
    void method() {
        System.out.println("父类方法");
    }
}

class Child extends Parent {
    @Override
    void method() {
        System.out.println("子类方法");
    }
}
```
_p.s. 单一继承：Java 不支持多继承，一个类只能有一个直接父类。多重继承可以通过接口来实现。_

##### 使用 super 关键字调用父类构造方法与方法

```java
class Parent {
    Parent() {
        System.out.println("父类构造方法");
    }

    void method() {
        System.out.println("父类方法");
    }
}

class Child extends Parent {
    Child() {
        super(); // 调用父类构造方法，必须在子类构造方法的第一行
        System.out.println("子类构造方法");
    }

    @Override
    void method() {
        super.method(); // 调用父类方法
        System.out.println("子类方法");
    }
}
```

##### 方法重写与重载

- **方法重写（Override）**：子类可以重写父类的方法，实现对父类方法的扩展或修改。重写方法必须**与父类方法具有相同的名称、参数列表和返回类型**。
- **方法重载（Overloading）**：在同一类或由于继承而相关的不同类中，**定义多个同名但参数不同的方法**，根据传入的参数不同来确定调用哪个方法。

```java
class Parent {
    void method(int a) {
        System.out.println("父类方法，参数为：" + a);
    }
}

class Child extends Parent {
    @Override
    void method(int a) {
        System.out.println("子类方法，参数为：" + a);
    }
}
```

实例化子类并调用方法，调用的都是定义在 Child 类中的方法 method。如果子类没有重写该方法，就会调用父类的方法。

```java
Child child = new Child();
child.method(10); // 输出：子类方法，参数为：10
```

方法重载（Overloading）示例：

```java
class Parent {
    void method(int a) {
        System.out.println("父类方法，参数为：" + a);
    }

    void method(int a, int b) {
        System.out.println("父类方法，参数为：" + a + "，" + b);
    }
}

class Child extends Parent {
    void method(double a, double b) {
        System.out.println("子类方法，参数为：" + a + "，" + b);
    }

    void method(int a, int b, int c) {
        System.out.println("子类方法，参数为：" + a + "，" + b + "，" + c);
    }
}
```

实例化一个子类对象，并调用方法，根据传递的参数类型，决定调用不同的方法：

```java
Child child = new Child();
child.method(10); // 父类方法，参数为：10 
child.method(10, 20); // 父类方法，参数为：10，20
child.method(10.0, 20.0); // 子类方法，参数为：10.0，20.0
child.method(10, 20, 30); // 子类方法，参数为：10，20，30
```

_p.s. 方法重写具有同样的签名和返回值类型；方法重载具有同样的名字，但是参数列表不同。_

##### 防止扩展与方法重写

**被 final 修饰的类和方法都不能被扩展。被 final 修饰的数据域是一个常数。**

在这种前提下，使用 final 修饰符表明一个类是最终的，是不能作为父类的；也可以定义一个方法是最终的，最终方法不能被它的子类重写。

#### 多态

##### 基本使用

在继承关系下，子类是它的父类的特殊化，每个子类的实例都是其父类的实例，但是反过来就不成立。

以下代码演示了多态。func 方法接受一个 Parent 类型的参数，但是在调用时传入了一个 Child 类型的参数。这是因为 Child 是 Parent 的子类，所以 Child 类型的对象也是 Parent 类型的对象。这就是多态的一种表现形式。

```java
public class Parent {
    void someMethod() {
        System.out.println("父类方法");
    }
}

public class Child extends Parent {
    @Override
    void someMethod() {
        System.out.println("子类方法");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        func(new Parent());
        func(new Child()); // 多态
    }

    public void func(Parent p) {
        p.someMethod();
    }
}
```

##### 动态绑定

```java
// toString() 是 Object 类中定义的方法，假设在 Child 中重写了 toString() 方法
Object o = new Child();
System.out.println(o.toString()); 
```

**分析**：o.toString() 调用的是谁的 toString() 方法？

两个基本概念：

- **声明类型（Declared Type）**：变量声明时使用的类型。
- **实际类型（Actual Type）**：对象实际所属的类型。

在上述例子中，o 的声明类型是 Object，而实际类型是 Child。之后，o 要调用谁的 toString() 方法，由 o 的实际类型决定。这里，由于 o 的实际类型是 Child，故调用的是 Child 类中重写的 toString() 方法。这就称为动态绑定（Dynamic Binding）。

#### instanceof 运算符

**instanceof** 运算符用于测试一个对象是否是指定类的实例，或者是否是该类的子类的实例。它返回一个布尔值。

```java
Parent p = new Child();
boolean b = p instanceof Child; // true
```

#### 对象转换

在多态中，父类引用可以指向子类对象（隐式转换），但是子类引用不能指向父类对象。如果要将父类引用转换为子类引用，需要使用强制类型转换。

##### 隐式转换

在多态的例子中，语句：

```java
func(new Child());
```

将对象 new Child() 传递给 func 方法时，会发生隐式转换，将 Child 类型的对象转换为 Parent 类型的对象。等价于：

```java
Parent p = new Child();
func(p); // 隐式转换（implicit casting）
```

##### 显式转换

_子实例**永远**是它的父类的实例。_

```java
// 以下语句会出错
Parent p = new Parent();
Child child = p; // 编译错误：不能将 Parent 类型转换为 Child 类型

// 强制类型转换（或向上转换 explicit casting）
Child c = (Child) p; 
```

#### Object 类的 equals 方法

equals 方法用于比较两个对象是否相等。默认情况下，equals 方法比较的是对象的引用是否相等，即是否指向同一个内存地址。

_ == 运算符可以检测两个引用变量是否指向同一个对象。_

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true; // 引用相等，直接返回 true
    if (obj == null || getClass() != obj.getClass()) return false; // 类型不匹配，返回 false
    Parent other = (Parent) obj; // 强制类型转换，将 obj 转换为 Parent 类型
    return true; // 假设所有字段都相等，返回 true
}
```

#### ArrayList 类

```java
import java.util.ArrayList;

ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
```

| 操作             | 数组                                    | ArrayList                             |
|------------------|-----------------------------------------|----------------------------------------|
| 创建             | `int[] arr = new int[3];`              | `ArrayList<Integer> list = new ArrayList<>();` |
| 引用元素         | `int x = arr[i];`                      | `int x = list.get(i);`                |
| 更新元素         | `arr[i] = 10;`                         | `list.set(i, 10);`                    |
| 返回大小         | `int n = arr.length;`                  | `int n = list.size();`                |
| 添加一个新元素   | 不可直接扩容，需创建新数组并拷贝       | `list.add(10);`                       |
| 插入一个新元素   | 需手动移动后续元素并赋值               | `list.add(index, 10);`                |
| 删除一个元素     | 需手动移动后续元素并可选调整长度       | `list.remove(index);` 或 `list.remove(Object o);` |
| 删除所有元素     | 需手动遍历并重置/创建新数组            | `list.clear();`                       |


## 数据结构与算法

### 链表

#### 反转链表（迭代法）

```c
struct ListNode { // 单链表结点定义
    int val;      // 结点值
    ListNode* next; // 指向下一个结点的指针
};

ListNode* reverseList(ListNode* head) { // 迭代反转单链表，返回新头结点
    ListNode* prev = nullptr; // 已反转部分的前驱指针，初始为空
    ListNode* curr = head;    // 当前遍历的结点
    while (curr != nullptr) { // 遍历直到链表尾部
        ListNode* next = curr->next; // 暂存后继，防止断链
        curr->next = prev;           // 反转当前结点指针指向
        prev = curr;                 // 前驱前移到当前结点
        curr = next;                 // 当前指针前进到原后继
    }
    return prev; // 返回新的头结点（原链表的尾结点）
}
```

#### 链表使用场景优缺点

**使用场景：**

**动态数据结构：** 链表的长度可以动态变化，适合存储数量不确定的数据。
**频繁插入和删除：** 在链表中进行插入和删除操作只需要修改指针，时间复杂度为 O (1)，比数组高效。

**优点：**

**动态大小：** 可以根据需要随时增加或减少节点数量。
**高效的插入和删除：** 不需要移动大量数据，只需修改指针。

**缺点：**

**随机访问困难：** 不像数组可以通过索引直接访问元素，链表需要从头节点开始遍历才能找到特定的节点。
**占用额外的内存空间：** 每个节点都需要存储指向下一个节点的指针，增加了内存开销。
### 二叉树

#### 二叉树的重要性质（结点数量）

1. 第 i 层上至多有 _2^(i - 1)_ 个结点
2. 深度为 k 的二叉树 **至多** 有 _2^k - 1_ 个结点 
3. 对任意一颗二叉树，_n0 = n2 + 1_

证明（可推理任何 T 元树（有根有向树））如下：

设有一棵有限的有根有向 T-元树（每个结点的出度 $\le T$ ）。记

•	$n$ 为结点总数，
•	$n_k$ 为出度为 k 的结点个数（$k=0,1,\dots,T$），
•	$B$ 为边（弧）的总数。

显然
$$n = n_0 + n_1 + n_2 + \cdots + n_T. \tag{1}$$

由于树是有根的、每个非根结点恰有一条入边，所以边的总数等于结点数减一：
$$B = n - 1. \tag{2}$$

另一方面，按出度分类，每个出度为 k 的结点贡献 k 条出边，因此
$$B = 1\cdot n_1 + 2\cdot n_2 + \cdots + T\cdot n_T. \tag{3}$$

由(2)与(3)得到
$$n - 1 = n_1 + 2n_2 + \cdots + T n_T,$$
即
$$n = n_1 + 2n_2 + \cdots + T n_T + 1. \tag{4}$$

将(1)与(4)相减（左边 $n$ 相同，右边相减得到 $n_0$）：
$$n_0 = (n_1 + n_2 + \cdots + n_T) - (n_1 + 2n_2 + \cdots + T n_T) + 1.$$
化简项得到
$$ n_0 = n_2 + 2n_3 + 3n_4 + \cdots + (T-1)n_T + 1.$$

这是对一般 T-元树的关系。
当 $T=2$（二叉树）时，所有 $n_3,n_4,\dots,n_T$ 都为 0，所以上式化为
$$n_0 = n_2 + 1$$
#### 根据中序遍历 (LDR) + 先序/后序遍历 确定唯一的二叉树

**先序或后序遍历可以确定根结点；通过中序遍历可以划分左右子树。**
递归上述过程，可以确定唯一的二叉树。

### 查找

### 排序

#### 插入排序

##### 直接插入排序

将序列划分为已排序区和未排序区。每次从未排序区取出一个元素，插入到已排序区的合适位置，使已排序区保持有序。插入过程通过向左扫描并右移所有比它大的元素来完成，适合小规模或近乎有序的数据，稳定。

1. 从索引 1 开始，视 `array[0...i-1]` 为已排序。
2. 取当前元素 `array[i]` 为 `temp`，若 `temp` 小于前驱则进入插入流程。
3. 从 `j=i-1` 向左扫描，凡比 `temp` 大的元素右移一位。
4. 扫描结束后，将 `temp` 放到 `j+1` 位置。
5. 重复直到末尾。

```js
let InsertSort = (array) => { // 定义插入排序函数，参数为数组
    let i, j // 外层和内层循环索引
    let temp // 临时存储当前待插入的元素
    for( i = 1; i < array.length; i++) { // 从索引 1 开始遍历，左侧视为已排序
        if (array[i] < array[i-1]) { // 当前元素比前一元素小，启动插入流程
            temp = array[i] // 把当前元素保存到临时变量
            array[i] = array[i - 1] // 先将前一个元素右移一位，为插入腾出空间
            for ( j = i-1; j >= 0 && array[j] > temp; j--) { // 向左扫描，移动所有大于 temp 的元素
                array[j + 1] = array[j] // 将较大的元素右移一位
            } // 内层循环结束
            array[j + 1] = temp // 在正确位置插入 temp
        } // 条件判断结束
    } // 外层循环结束
} // 函数结束
```

##### 希尔排序

先将整个待排序记录序列分割为几组，从而减少参与直接插入排序的数据量，对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样，当经过几次分组排序后，整个序列中的元素基本有序，再进行一次直接插入排序，即可完成排序。

希尔排序的分组，不是简单地将序列分成等长的子序列，而是根据一个增量序列进行分组。增量序列的最后一个增量必须为 1，即最后一次排序时，整个序列被分为一组，进行直接插入排序。

1. 第一趟取增量 $d_1 (d_1 < n)$，把全部记录分成 $d_1$ 组，所有间隔为 $d_1$ 的记录分在同一组，对每组分别进行直接插入排序。
2. 第二趟取增量 $d_2 (d_2 < d_1)$，把全部记录分成 $d_2$ 组，所有间隔为 $d_2$ 的记录分在同一组，对每组分别进行直接插入排序。
3. 重复以上过程，直到取增量为 1，即最后一次排序时，整个序列被分为一组，进行直接插入排序。

#### 交换排序

##### 冒泡排序

通过相邻元素的比较与交换，使较大的元素逐步“冒泡”到序列右端。每一趟都能确定一个最大值的位置；若某一趟未发生交换，则序列已整体有序，可提前结束。算法简单、稳定，适合教学与入门。

1. 外层控制趟数，共 `n-1` 趟。
2. 内层从头到 `n-i-2` 比较相邻元素，若逆序则交换。
3. 若某一趟没有发生交换，说明序列已有序，提前退出。

```js
function BubbleSort(arr) { // 冒泡排序（含提前退出优化），返回有序新数组
    let flag = 1            // 标志位：上一轮是否发生交换；用于提前结束
    let array = [...arr]    // 复制原数组，避免修改入参

    for (let i = 0; i < array.length - 1 && flag; i++) { // 外层循环控制趟数；若上一趟无交换则提前退出
        flag = 0           // 新一趟开始前重置标志位
        for (let j = 0; j < array.length - i - 1; j++) { // 内层循环：比较相邻元素，将较大值向右“冒泡”
            if (array[j] > array[j+1]) { // 若前一个元素比后一个大则交换
                let temp = array[j]      // 交换相邻元素
                array[j] = array[j+1]
                array[j+1] = temp
                flag = 1                 // 本趟发生交换，保持继续下一趟
            }
        } 
    }

    return array            // 返回排序后的数组副本
}
```

##### 快速排序(双指针法)

分治思想：选取枢轴，将序列按与枢轴的大小关系划分为两个子序列（左侧小于等于枢轴，右侧大于等于枢轴），再递归地对两侧排序。本实现采用双指针“填坑”法进行原地分区，空间开销低。

1. 选枢轴：取子数组首元素 `arr[low]`。
2. 分区：设 `low`、`high` 双指针向中间收缩。右侧向左找第一个小于枢轴的元素填到左坑；左侧向右找第一个大于枢轴的元素填到右坑。
3. 当 `low==high` 时，将枢轴放回该位置，分区完成，返回枢轴下标。
4. 分别递归处理左区间 `[low, pivotLoc-1]` 与右区间 `[pivotLoc+1, high]`。

```js
function QuickSort(arr) { // 快速排序入口函数，返回有序新数组
    let array = [...arr]   // 复制入参，避免修改原数组
    QSort(array, 0, array.length - 1) // 对整个区间进行原地快排
    return array           // 返回排序结果副本
}

function QSort(arr, low, high) { // 对区间 [low, high] 原地快速排序
    if (low < high) { // 递归终止：当区间长度 ≤ 1 时无需处理
        let pivotLoc = Partition(arr, low, high) // 分区，得到枢轴的最终位置
        QSort(arr, low, pivotLoc - 1)            // 递归排序枢轴左半段
        // QSort(arr, pivotLoc, high)
        // 错因：右半段递归用了 pivotLoc 而不是 pivotLoc + 1 。当 pivotLoc === low 时，区间不缩小，递归死循环。
        QSort(arr, pivotLoc + 1, high)           // 递归排序枢轴右半段（从 pivotLoc+1 开始）
    }
}

function Partition(arr, low, high) { // 双指针分区（“填坑”法），返回枢轴最终位置
    // const pivotKey = arr[0] 
    // 错因：分区函数总是用 arr[0] 作为枢轴，而不是当前子数组的 arr[low] ，递归到子数组时分区错误，也会让递归无法收敛。
    const pivotKey = arr[low] // 选当前子数组首元素为枢轴值

    while (low < high) { // 双指针向中间收缩
        while (low < high && arr[high] >= pivotKey) high-- // 右侧寻找第一个 < pivot 的元素
        arr[low] = arr[high]                                // 填左侧“坑”：把较小值放到左侧
        while (low < high && arr[low] <= pivotKey) low++   // 左侧寻找第一个 > pivot 的元素
        arr[high] = arr[low]                                // 填右侧“坑”：把较大值放到右侧
    }
    arr[low] = pivotKey   // 将枢轴放回最终位置（low）
    return low            // 返回枢轴位置供上层递归使用
}
```

#### 选择排序

##### 简单选择排序

每一趟在未排序区间中选择最小元素，将其与当前起始位置交换，扩大已排序区。选择排序比较次数固定、交换次数较少，但总体效率仍为 `O(n^2)`，且通常不稳定。

1. 外层遍历 `i=0...n-1`，视 `array[0...i-1]` 为已排序。
2. 在未排序区 `[i, n-1]` 中扫描，记录最小值的下标 `minIndex`。
3. 若 `minIndex != i`，交换 `array[minIndex]` 与 `array[i]`。

```js
let SelectSort = (arr) => {
    let n = arr.length
    let array = [...arr]
    // 外层循环：遍历整个数组，i 表示当前已排序部分的末尾索引
    for (let i = 0; i < n; i++) {
        let minIndex = i
        // 内层循环：在未排序区域 [i+1, n-1] 中查找实际的最小元素
        for (let j = i + 1; j < n; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j
            }
        }
        // 如果找到的最小元素不是当前位置 i 的元素，则进行交换
        if (minIndex !== i) {
                [array[minIndex], array[i]] = [array[i], array[minIndex]]
            }
    }
    return array
}
```

#### 归并排序

分治与合并：递归地将序列二分，分别排序后再线性合并两个有序子序列，得到更大的有序序列。归并排序稳定，时间复杂度为 `O(n log n)`。

1. 将区间 `[low, high]` 二分为 `[low, mid]` 与 `[mid+1, high]`。
2. 递归地对两段排序。
3. 使用两个指针分别指向两段起始位置，比较当前元素并将较小者写入辅助数组。
4. 将剩余元素依次写入辅助数组。
5. 将辅助数组的 `[low...high]` 拷贝回原数组。

```js
// 相邻两个有序子序列的合并
// 将 src[low...mid] 和 src[mid+1...high] 合并到 res
function Merge(src, res, low, mid, high) {
    let i = low, j = mid + 1, k = low
    while (i <= mid && j <= high) {
        if (src[i] <= src[j]) res[k++] = src[i++]
        else res[k++] = src[j++]
    }
    while (i <= mid) res[k++] = src[i++]
    while (j <= high) res[k++] = src[j++]
}

// 归并排序
// 将 src 归并排序后放入 res 中
function MSort(src, res, low, high) {
    if (low >= high) return
    const mid = (low + high) >> 1
    MSort(src, res, low, mid)
    MSort(src, res, mid + 1, high)
    Merge(src, res, low, mid, high)
    for (let i = low; i <= high; i++) src[i] = res[i]
}

function MergingSort(arr) {
    const tmp = new Array(arr.length)
    MSort(arr, tmp, 0, arr.length - 1)
    return arr
}
```

## 计算机网络

### 七层结构与协议

### 常见端口

|**端口号**|**协议/服务**|**备注**|
|---|---|---|
|20/21|FTP|21 控制，20 数据（古典传输方式）|
|22|SSH|远程登录的常客|
|23|Telnet|明文传输的上古神器，基本淘汰|
|25|SMTP|发邮件|
|53|DNS|TCP/UDP 都有，域名解析的基石|
|67/68|DHCP|自动分配 IP|
|80|HTTP|明文网页|
|110|POP3|收邮件（较旧）|
|123|NTP|网络时间同步|
|143|IMAP|收邮件（主流）|
|161/162|SNMP|网络设备管理|
|389|LDAP|目录服务|
|443|HTTPS|加密网页，现代互联网的主干|
|465/587|SMTPS / SMTP Submission|加密或客户端发送邮件|
|993|IMAPS|加密的 IMAP|
|3306|MySQL|数据库|
|5432|PostgreSQL|数据库|
|6379|Redis|缓存/键值存储|
|27017|MongoDB|文档数据库|

### 常见响应状态码

|**状态码**|**意义**|**描述**|
|---|---|---|
|200|OK|一切顺利|
|201|Created|资源成功创建|
|204|No Content|成功但无内容返回|
|301|Moved Permanently|永久重定向|
|302|Found|临时重定向|
|304|Not Modified|客户端可用缓存|
|400|Bad Request|请求格式不对|
|401|Unauthorized|缺少认证|
|403|Forbidden|有身份但没权限|
|404|Not Found|找不到资源|
|405|Method Not Allowed|方法不被允许|
|408|Request Timeout|请求超时|
|429|Too Many Requests|触发限流|
|500|Internal Server Error|服务器内部错误|
|502|Bad Gateway|网关收到坏响应|
|503|Service Unavailable|服务不可用（可能在维护）|
|504|Gateway Timeout|上游超时|

### TCP & UDP

连接性：TCP 是面向连接的协议，在通信之前需要建立连接；UDP 是无连接的协议，不需要建立连接。
可靠性：TCP 提供可靠的数据传输，通过确认机制、重传机制和流量控制保证数据的正确传输；UDP 不保证数据的可靠传输，可能会出现丢包、乱序等情况。
传输效率：UDP 传输效率高，因为它不需要建立连接和进行复杂的确认机制；TCP 传输效率相对较低，但保证了数据的可靠性。
头部开销：TCP 头部开销大，因为它需要包含更多的控制信息；UDP 头部开销小。

### 跨域问题
## 操作系统

### 文件系统的作用

### 进程线程协程

**进程**：是操作系统进行资源分配和调度的基本单位，拥有独立的内存空间和系统资源。
**线程**：是进程中的一个执行单元，共享进程的内存空间和系统资源。线程的创建和切换比进程轻量级。
**协程**：是一种用户态的轻量级线程，由程序员自己控制协程的切换，不需要操作系统进行调度。协程的切换开销非常小，可以在一个线程中同时运行多个协程。

### 线程安全

线程安全是指多个线程同时访问一个对象或方法时，不会出现数据不一致或错误的情况。实现线程安全的方法有：

1. 使用同步机制，如锁（互斥锁、读写锁等）、信号量等。
2. 使用不可变对象。
## 计算机组成
