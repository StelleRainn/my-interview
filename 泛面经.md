# 比较泛的面试问题（非前端）

## 编程语言

### Java 的三大特性

封装、继承、多态
## 数据结构与算法

### 链表

#### 反转链表（迭代法）

```c
struct ListNode { // 单链表结点定义
    int val;      // 结点值
    ListNode* next; // 指向下一个结点的指针
};

ListNode* reverseList(ListNode* head) { // 迭代反转单链表，返回新头结点
    ListNode* prev = nullptr; // 已反转部分的前驱指针，初始为空
    ListNode* curr = head;    // 当前遍历的结点
    while (curr != nullptr) { // 遍历直到链表尾部
        ListNode* next = curr->next; // 暂存后继，防止断链
        curr->next = prev;           // 反转当前结点指针指向
        prev = curr;                 // 前驱前移到当前结点
        curr = next;                 // 当前指针前进到原后继
    }
    return prev; // 返回新的头结点（原链表的尾结点）
}
```

### 二叉树

#### 二叉树的重要性质（结点数量）

1. 第 i 层上至多有 _2^(i - 1)_ 个结点
2. 深度为 k 的二叉树 **至多** 有 _2^k - 1_ 个结点 
3. 对任意一颗二叉树，_n0 = n2 + 1_
证明（可推理任何 T 元树（有根有向树））：
设有一棵有限的有根有向 T-元树（每个结点的出度 $\le T$ ）。记

•	$n$ 为结点总数，
•	$n_k$ 为出度为 k 的结点个数（$k=0,1,\dots,T$），
•	$B$ 为边（弧）的总数。

显然
$$n = n_0 + n_1 + n_2 + \cdots + n_T. \tag{1}$$

由于树是有根的、每个非根结点恰有一条入边，所以边的总数等于结点数减一：
$$B = n - 1. \tag{2}$$

另一方面，按出度分类，每个出度为 k 的结点贡献 k 条出边，因此
$$B = 1\cdot n_1 + 2\cdot n_2 + \cdots + T\cdot n_T. \tag{3}$$

由(2)与(3)得到
$$n - 1 = n_1 + 2n_2 + \cdots + T n_T,$$
即
$$n = n_1 + 2n_2 + \cdots + T n_T + 1. \tag{4}$$

将(1)与(4)相减（左边 $n$ 相同，右边相减得到 $n_0$）：
$$n_0 = (n_1 + n_2 + \cdots + n_T) - (n_1 + 2n_2 + \cdots + T n_T) + 1.$$
化简项得到
$$ n_0 = n_2 + 2n_3 + 3n_4 + \cdots + (T-1)n_T + 1.$$

这是对一般 T-元树的关系。
当 $T=2$（二叉树）时，所有 $n_3,n_4,\dots,n_T$ 都为 0，所以上式化为
$$n_0 = n_2 + 1$$
#### 根据中序遍历 (LDR) + 先序/后序遍历 确定唯一的二叉树

先序或后序遍历可以确定根结点；通过中序遍历可以划分左右子树。
递归上述过程，可以确定唯一的二叉树。

### 查找

### 排序

##### 直接插入排序

```js
let Insertsort = (array) => { // 定义插入排序函数，参数为数组
    let i, j // 外层和内层循环索引
    let temp // 临时存储当前待插入的元素
    for( i = 1; i < array.length; i++) { // 从索引 1 开始遍历，左侧视为已排序
        if (array[i] < array[i-1]) { // 当前元素比前一元素小，启动插入流程
            temp = array[i] // 把当前元素保存到临时变量
            array[i] = array[i - 1] // 先将前一个元素右移一位，为插入腾出空间
            for ( j = i-1; j>=0; j--) { // 向左扫描，移动所有大于 temp 的元素
                if (array[j] > temp) array[j + 1] = array[j] // 将较大的元素右移一位
            } // 内层循环结束
            array[j + 1] = temp // 在正确位置插入 temp
        } // 条件判断结束
    } // 外层循环结束
} // 函数结束
```

##### 简单选择排序

```js
let SelectSort = (arr) => {
    let n = arr.length
    let array = [...arr]
    // 外层循环：遍历整个数组，i 表示当前已排序部分的末尾索引
    for (let i = 0; i < n; i++) {
        let minIndex = i
        // 内层循环：在未排序区域 [i+1, n-1] 中查找实际的最小元素
        for (let j = i + 1; j < n; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j
            }
        }
        // 如果找到的最小元素不是当前位置 i 的元素，则进行交换
        if (minIndex !== i) {
                [array[minIndex], array[i]] = [array[i], array[minIndex]]
            }
    }
    return array
}
```

## 计算机网络

### 七层结构与协议

### 常见响应代码

### 跨域问题
## 操作系统

### 文件系统的作用
## 计算机组成
